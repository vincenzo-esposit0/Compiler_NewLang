import nodes.*;
import java.util.ArrayList;

terminal MAIN, SEMI, COMMA, PIPE, VAR, INTEGER, REAL, STRING, BOOL, CHAR, VOID,
         DEF, OUT, FOR, IF, ELSE, WHILE, TO, THEN, LOOP, READ, WRITE, WRITELN,
         LPAR, RPAR, LBRACK, RBRACK, COLON, ASSIGN, RETURN,
         TRUE, FALSE, PLUS, MINUS, TIMES, DIV, POW, STR_CONCAT,
         EQUALS, NE, LT, LE, GT, GE, AND, OR, NOT;

terminal String ID, STRING_CONST;
terminal Integer INTEGER_CONST;
terminal Float REAL_CONST;
terminal Character CHAR_CONST;

nonterminal Program;
nonterminal DeclList;
nonterminal MainFunDecl;
nonterminal VarDecl;
nonterminal Type;
nonterminal IdInitList;
nonterminal IdInitObblList;
nonterminal Const;
nonterminal FunDecl;
nonterminal Body;
nonterminal ParamDeclList;
nonterminal NonEmptyParamDeclList;
nonterminal ParDecl;
nonterminal TypeOrVoid;
nonterminal VarDeclList;
nonterminal StatList;
nonterminal Stat;
nonterminal IfStat;
nonterminal Else;
nonterminal WhileStat;
nonterminal ForStat;
nonterminal ReadStat;
nonterminal IdList;
nonterminal WriteStat;
nonterminal AssignStat;
nonterminal FunCall;
nonterminal ExprList;
nonterminal Expr;

// **************** Specifica precedence ****************

//precedence nonassoc FOR, WHILE, IF, LPAR, RBRACK, RETURN, ID;
precedence left OR, AND;
precedence right NOT;
precedence left GT, GE;
precedence left EQUALS, NE, LT, LE;
precedence left STR_CONCAT;
precedence left PLUS, MINUS;
precedence left DIV, TIMES;
precedence right POW;
precedence left RBRACK;

// **************** Specifica grammaticale ****************

//Program ::= DeclList MainFunDecl DeclList
Program ::= DeclList:declList1 MainFunDecl: mainFunDecl DeclList:declList2
    {: RESULT = new ProgramNode("ProgramOp", (ArrayList<DeclListNode>)declList1, (MainFunDeclNode)mainFunDecl, (ArrayList<DeclListNode>)declList2); :};

//DeclList ::= VarDecl DeclList | FunDecl DeclList | empty
DeclList ::= VarDecl:varDecl DeclList:declList1 {:
                if (declList1 == null) {
                    declList1 = new ArrayList<DeclListNode>();
                }
                ((ArrayList<DeclListNode>)declList1).add(new DeclListNode("DeclList", (VarDeclNode)varDecl,(ArrayList<DeclListNode>)declList1));
                RESULT = declList1;
            :}
           | FunDecl:funDecl DeclList:declList1 {:
                if (declList1 == null) {
                    declList1 = new ArrayList<DeclListNode>();
                }
                ((ArrayList<DeclListNode>)declList1).add(new DeclListNode("DeclList", (FunDeclNode)funDecl, (ArrayList<DeclListNode>)declList1));
                RESULT = declList1;
            :}
           | /* empty */ {: RESULT = new DeclListNode(); :};

//MainFunDecl ::= MAIN FunDecl
MainFunDecl ::= MAIN FunDecl:funDecl {: RESULT = new MainFunDeclNode("MainFunDecl", (FunDeclNode)funDecl); :};

//VarDecl ::= Type IdInitList SEMI | VAR IdInitObblList SEMI
VarDecl ::= Type:type IdInitList:idInitList SEMI {: RESULT = new VarDeclNode("VarDecl", (TypeNode)type, (ArrayList<IdInitListNode>)idInitList); :}
          | VAR IdInitObblList:idInitObblList SEMI {: RESULT = new VarDeclNode((ArrayList<IdInitObblListNode>)idInitObblList); :};

//Type ::= INTEGER | BOOL | REAL | STRING | CHAR
Type ::= INTEGER    {: RESULT = new TypeNode("TypeNode", TypeNode.INTEGER); :}
       | BOOL       {: RESULT = new TypeNode("TypeNode",TypeNode.BOOL); :}
       | REAL       {: RESULT = new TypeNode("TypeNode",TypeNode.REAL); :}
       | STRING     {: RESULT = new TypeNode("TypeNode",TypeNode.STRING); :}
       | CHAR       {: RESULT = new TypeNode("TypeNode",TypeNode.CHAR); :};

//IdInitList ::= ID | IdInitList COMMA ID | ID ASSIGN Expr | IdInitList COMMA ID ASSIGN Expr
IdInitList ::= ID:id {:
                ArrayList<IdInitListNode> idInitList = new ArrayList<>();
                idInitList.add(new IdInitListNode(null, new IdNode("IdNode", id), null));
                RESULT = idInitList;
             :}
             | IdInitList:idInitList COMMA ID:id {:
                ((ArrayList<IdInitListNode>)idInitList).add(new IdInitListNode((ArrayList<IdInitListNode>)idInitList, new IdNode("IdNode", id), null));
                RESULT = idInitList;
             :}
             | ID:id ASSIGN Expr:expr {:
                ArrayList<IdInitListNode> idInitList = new ArrayList<>();
                idInitList.add(new IdInitListNode(null, new IdNode("IdNode",id), (ExprNode)expr));
                RESULT = idInitList;
             :}
             | IdInitList:idInitList COMMA ID:id ASSIGN Expr:expr {:
                ((ArrayList<IdInitListNode>)idInitList).add(new IdInitListNode((ArrayList<IdInitListNode>)idInitList, new IdNode("IdNode", id), (ExprNode)expr));
                RESULT = idInitList;
             :};

//IdInitObblList ::= ID ASSIGN Const | IdInitObblList COMMA ID ASSIGN Const
IdInitObblList ::= ID:id ASSIGN Const:constant {:
                    ArrayList<IdInitObblListNode> idInitObblList = new ArrayList<>();
                    idInitObblList.add(new IdInitObblListNode(null, new IdNode("IdNode",id), (ConstNode)constant));
                    RESULT = idInitObblList;
                :}
                 | IdInitObblList:idInitObblList COMMA ID:id ASSIGN Const:constant {:
                    ((ArrayList<IdInitObblListNode>)idInitObblList).add(new IdInitObblListNode((ArrayList<IdInitObblListNode>)idInitObblList, new IdNode("IdNode",id), (ConstNode)constant));
                    RESULT = idInitObblList;
                :};

//Const ::= INTEGER_CONST | REAL_CONST | TRUE | FALSE | STRING_CONST | CHAR_CONST
Const ::= INTEGER_CONST:integerConst        {: RESULT = new ConstNode((Integer)integerConst); :}
        | REAL_CONST:realConst              {: RESULT = new ConstNode((Float)realConst); :}
        | TRUE                              {: RESULT = new ConstNode(true); :}
        | FALSE                             {: RESULT = new ConstNode(false); :}
        | STRING_CONST:stringConst          {: RESULT = new ConstNode((String)stringConst); :}
        | CHAR_CONST:charConst              {: RESULT = new ConstNode((Character)charConst); :};

//FunDecl ::= DEF ID LPAR ParamDeclList RPAR COLON TypeOrVoid Body
FunDecl ::= DEF ID:id LPAR ParamDeclList:paramDeclList RPAR COLON TypeOrVoid:typeOrVoid Body:body {: RESULT = new FunDeclNode("FunDeclNode", new IdNode("IdNode",id), (ArrayList<ParamDeclListNode>)paramDeclList, (String)typeOrVoid, (BodyNode)body); :};

//Body ::= LBRACK VarDeclList StatList RBRACK
Body ::= LBRACK VarDeclList:varDeclList StatList:statList RBRACK {: RESULT = new BodyNode((ArrayList<VarDeclListNode>)varDeclList, (ArrayList<StatListNode>)statList); :};

//ParamDeclList ::= empty | NonEmptyParamDeclList
ParamDeclList ::= /* empty */ {: RESULT = new ParamDeclListNode(); :}
                | NonEmptyParamDeclList:nonEmptyParamDeclList {:
                    ArrayList<ParamDeclListNode> paramDeclList = new ArrayList<>();
                    paramDeclList.add(new ParamDeclListNode((ArrayList<NonEmptyParamDeclListNode>)nonEmptyParamDeclList));
                    RESULT = paramDeclList;
                :};

//NonEmptyParamDeclList ::= ParDecl | NonEmptyParamDeclList PIPE ParDecl
NonEmptyParamDeclList ::= ParDecl:parDecl {:
                            ArrayList<NonEmptyParamDeclListNode> nonEmptyParamDeclList = new ArrayList<>();
                            nonEmptyParamDeclList.add(new NonEmptyParamDeclListNode((ParDeclNode)parDecl, null));
                            RESULT = nonEmptyParamDeclList;
                        :}
                        | NonEmptyParamDeclList:nonEmptyParamDeclList PIPE ParDecl:parDecl {:
                            ((ArrayList<NonEmptyParamDeclListNode>)nonEmptyParamDeclList).add(new NonEmptyParamDeclListNode((ParDeclNode)parDecl, (ArrayList<NonEmptyParamDeclListNode>)nonEmptyParamDeclList));
                            RESULT = nonEmptyParamDeclList;
                        :};

//ParDecl ::= Type IdList | OUT Type IdList
ParDecl ::= Type:type IdList:idList {: RESULT = new ParDeclNode("ParDecl", (TypeNode)type, (ArrayList<IdListNode>)idList, false); :}
          | OUT Type:type IdList:idList {: RESULT = new ParDeclNode("ParDecl", (TypeNode)type, (ArrayList<IdListNode>)idList, true); :};

//TypeOrVoid ::= Type | VOID
TypeOrVoid ::= Type:type {: RESULT = (TypeNode)type; :}
             | VOID {: RESULT = "VOID"; :};

//VarDeclList ::= empty | VarDecl VarDeclList
VarDeclList ::= /* empty */ {: RESULT = new VarDeclListNode(); :}
              | VarDecl:varDecl VarDeclList:varDeclList {:
                ((ArrayList<VarDeclListNode>)varDeclList).add(new VarDeclListNode((VarDeclNode)varDecl, (ArrayList<VarDeclListNode>)varDeclList));
                RESULT = varDeclList;
              :};

//StatList ::= Stat | Stat StatList
StatList ::= /* empty */ {: RESULT = new StatListNode(); :}
           | Stat:stat StatList:statList {:
                ((ArrayList<StatListNode>)statList).add("StatList", new StatListNode((StatNode)stat, (ArrayList<StatListNode>)statList));
                RESULT = statList;
           :};

//Stat ::= IfStat | ForStat | ReadStat SEMI | WriteStat SEMI | AssignStat SEMI | WhileStat | FunCall SEMI | RETURN Expr SEMI | Return SEMI | Return | empty
Stat ::= IfStat:ifStat
        {: RESULT = new StatNode("IfStat", (IfStatNode)ifStat); :}
	   | ForStat:forStat
        {: RESULT = new StatNode("ForStat",(ForStatNode)forStat); :}
	   | ReadStat:readStat SEMI
        {: RESULT = new StatNode("ReadStat",(ReadStatNode)readStat); :}
	   | WriteStat:writeStat SEMI
        {: RESULT = new StatNode("WriteStat",(WriteStatNode)writeStat); :}
	   | AssignStat:assignStat SEMI
        {: RESULT = new StatNode("AssignStat",(AssignStatNode)assignStat); :}
       | WhileStat:whileStat
        {: RESULT = new StatNode("WhileStat",(WhileStatNode)whileStat); :}
	   | FunCall:funCall SEMI
        {: RESULT = new StatNode("FunStat",(FunCallNode)funCall); :}
	   | RETURN Expr:expr SEMI
        {: RESULT = new StatNode("Expr",(ExprNode)expr); :}
	   | RETURN SEMI
        {: RESULT = new StatNode(); :}
	   | /* empty */
        {: RESULT = null; :};

//IfStat ::= IF Expr THEN Body Else
IfStat ::= IF Expr:expr THEN Body:body Else:elseStat {: RESULT = new IfStatNode("IfStatNode", (ExprNode)expr, (BodyNode)body, (ElseNode)elseStat); :};

//Else ::= empty | ELSE Body
Else ::= /* empty */ {: RESULT = null; :}
       | ELSE Body:body {: RESULT = new ElseNode("ElseStatNode", (BodyNode)body); :};

//WhileStat ::= WHILE Expr LOOP Body
WhileStat ::= WHILE Expr:expr LOOP Body:body {: RESULT = new WhileStatNode("WhileStatNodes", (ExprNode)expr, (BodyNode)body); :};

//ForStat ::= FOR ID ASSIGN INTEGER_CONST TO INTEGER_CONST LOOP Body
ForStat ::= FOR ID:id ASSIGN INTEGER_CONST:intConst1 TO INTEGER_CONST:intConst2 LOOP Body:body {: RESULT = new ForStatNode("ForStat", new IdNode(id), new ConstNode((Integer)intConst1), new ConstNode((Integer)intConst2), (BodyNode)body); :};

//ReadStat ::= IdList READ STRING_CONST | IdList READ
ReadStat ::= IdList:idList READ STRING_CONST:stringConst {: new ReadStatNode("ReadStatNode", (ArrayList<IdListNode>)idList, new ConstNode((String)stringConst)); :}
           | IdList:idList READ {: new ReadStatNode("ReadStatNode", (ArrayList<IdListNode>)idList, null); :};

//IdList ::= ID | IdList COMMA ID
IdList ::= ID:id {:
            ArrayList<IdListNode> idList = new ArrayList<>();
            idList.add(new IdListNode(new IdNode(id), null));
            RESULT = idList;
         :}
         | IdList:idList COMMA ID:id {:
            ((ArrayList<IdListNode>)idList).add(new IdListNode(new IdNode(id), (ArrayList<IdListNode>)idList));
            RESULT = idList;
         :};

//WriteStat ::= LPAR ExprList RPAR WRITE | LPAR ExprList RPAR WRITELN;
WriteStat ::= LPAR ExprList:exprList RPAR WRITE {: RESULT = new WriteStatNode((ArrayList<ExprListNode>)exprList, "WRITE"); :}
              | LPAR ExprList:exprList RPAR WRITELN {: RESULT = new WriteStatNode((ArrayList<ExprListNode>)exprList, "WRITELN"); :};

//AssignStat ::=  IdList ASSIGN ExprList
AssignStat ::= IdList:idList ASSIGN ExprList:exprList {: RESULT = new AssignStatNode((ArrayList<IdListNode>)idList, (ArrayList<ExprListNode>)exprList); :};

//FunCall ::= ID LPAR ExprList RPAR | ID LPAR RPAR
FunCall ::= ID:id LPAR ExprList:exprList RPAR {: RESULT = new FunCallNode(new IdNode(id), (ArrayList<ExprListNode>)exprList); :}
	      | ID:id LPAR RPAR {: RESULT = new FunCallNode(new IdNode(id), null); :};

//ExprList ::= Expr | Expr COMMA ExprList
ExprList ::= Expr:expr {:
                ArrayList<ExprListNode> exprList = new ArrayList<>();
                exprList.add(new ExprListNode((ExprNode)expr, null));
                RESULT = exprList;
           :}
	       | Expr:expr COMMA ExprList:exprList {:
                ((ArrayList<ExprListNode>)exprList).add(new ExprListNode((ExprNode)expr, (ArrayList<ExprListNode>)exprList));
                RESULT = exprList;
	       :};

//Expr ::= TRUE | FALSE | INTEGER_CONST | REAL_CONST | STRING_CONST | CHAR_CONST
//       | ID | FunCall | Expr PLUS Expr | Expr MINUS Expr | Expr TIMES Expr
//       | Expr DIV Expr | Expr AND Expr | Expr POW Expr | Expr STR_CONCAT Expr
//       | Expr OR Expr | Expr GT Expr | Expr GE Expr | Expr LT Expr | Expr LE Expr
//       | Expr EQUALS Expr | Expr NE Expr | MINUS Expr | NOT Expr | LPAR Expr RPAR
Expr ::= TRUE {: RESULT = new ExprNode("TRUE", new ConstNode(true)); :}
	   | FALSE {: RESULT = new ExprNode("FALSE", new ConstNode(false)); :}
	   | INTEGER_CONST:integerConst {: RESULT = new ExprNode("INTEGER_CONST", new ConstNode((Integer)integerConst)); :}
	   | REAL_CONST:realConst {: RESULT = new ExprNode("REAL_CONST", new ConstNode((Float)realConst)); :}
	   | STRING_CONST:stringConst {: RESULT = new ExprNode("STRING_CONST", new ConstNode((String)stringConst)); :}
	   | CHAR_CONST:charConst {: RESULT = new ExprNode("CHAR_CONST", new ConstNode((Character)charConst)); :}
	   | ID:id {: RESULT = new ExprNode("ID", new IdNode(id)); :}
	   | FunCall:funCall {: RESULT = new ExprNode("FUNCALL", (FunCallNode)funCall); :}
	   | Expr:expr1 PLUS Expr:expr2 {: RESULT = new ExprNode("PLUS", (ExprNode)expr1, (ExprNode)expr2); :}
	   | Expr:expr1 MINUS Expr:expr2 {: RESULT = new ExprNode("MINUS", (ExprNode)expr1, (ExprNode)expr2); :}
	   | Expr:expr1 TIMES Expr:expr2 {: RESULT = new ExprNode("TIMES", (ExprNode)expr1, (ExprNode)expr2); :}
	   | Expr:expr1 DIV Expr:expr2 {: RESULT = new ExprNode("DIV", (ExprNode)expr1, (ExprNode)expr2); :}
	   | Expr:expr1 AND Expr:expr2 {: RESULT = new ExprNode("AND", (ExprNode)expr1, (ExprNode)expr2); :}
	   | Expr:expr1 POW Expr:expr2 {: RESULT = new ExprNode("POW", (ExprNode)expr1, (ExprNode)expr2); :}
	   | Expr:expr1 STR_CONCAT Expr:expr2 {: RESULT = new ExprNode("STR_CONCAT", (ExprNode)expr1, (ExprNode)expr2); :}
	   | Expr:expr1 OR Expr:expr2 {: RESULT = new ExprNode("OR", (ExprNode)expr1, (ExprNode)expr2); :}
	   | Expr:expr1 GT Expr:expr2 {: RESULT = new ExprNode("GT", (ExprNode)expr1, (ExprNode)expr2); :}
	   | Expr:expr1 GE Expr:expr2 {: RESULT = new ExprNode("GE", (ExprNode)expr1, (ExprNode)expr2); :}
	   | Expr:expr1 LT Expr:expr2 {: RESULT = new ExprNode("LT", (ExprNode)expr1, (ExprNode)expr2); :}
	   | Expr:expr1 LE Expr:expr2 {: RESULT = new ExprNode("LE", (ExprNode)expr1, (ExprNode)expr2); :}
	   | Expr:expr1 EQUALS Expr:expr2 {: RESULT = new ExprNode("EQUALS", (ExprNode)expr1, (ExprNode)expr2); :}
	   | Expr:expr1 NE Expr:expr2 {: RESULT = new ExprNode("NE", (ExprNode)expr1, (ExprNode)expr2); :}
	   | MINUS Expr:expr1 {: RESULT = new ExprNode("MINUS", (ExprNode)expr1); :}
	   | NOT Expr:expr1 {: RESULT = new ExprNode("NOT", (ExprNode)expr1); :}
	   | LPAR Expr:expr1 RPAR {: RESULT = new ExprNode("INBRAC", (ExprNode)expr1); :};
